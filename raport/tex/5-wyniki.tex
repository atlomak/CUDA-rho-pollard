\newpage
\section{Wyniki}
\subsection{Testy implementacji}

Głównym celem pracy było znalezienie rozwiązania problemu logarytmu dyskretnego
dla krzywej ECCp79 z Certicom Challenge w możliwie najkrótszym czasie. Mimo że
rozmiar krzywej jest stosunkowo niewielki, a współczesny sprzęt znacznie
wydajniejszy od tego dostępnego w momencie pierwszych prób złamania tej krzywej,
obliczenie rozwiązania wciąż zajmuje czas liczony w godzinach.

Ze względu na czasochłonność pełnych obliczeń, niezbędne było przeprowadzenie
testów implementacji na mniejszych, uproszczonych problemach, które pozwoliłyby
na szybszą weryfikację poprawności algorytmu i jego działania. Testy te były
niezbędnym krokiem przed przystąpieniem do pełnoprawnych prób rozwiązania
problemu logarytmu dyskretnego dla krzywej ECCp79. Pozwoliły one na upewnienie się,
że implementacja działa poprawnie oraz spełnia wszystkie założenia teoretyczne.

W tym celu zostały wykorzystane środowiska PyTest oraz SageMath do przeprowadzenia testów
funkcjonalnych, weryfikujących poprawność operacji na krzywych eliptycznych
oraz kolejnych kroków algorytmu Rho Pollard'a.

Testy obejmowały następujące aspekty:
\begin{itemize}
    \item Poprawność dodawania punktów na krzywej eliptycznej:
          Wyniki obliczeń programu klienta były porównywane z wynikami uzyskanymi
          w SageMath.
    \item Weryfikacja pierwszych kilkuset iteracji algorytmu Rho Pollard'a:
          Sprawdzano zgodność wyników generowanych przez implementację z oczekiwanymi
          wartościami teoretycznymi.
    \item Sprawdzenie integralności przesyłanych danych pomiędzy serwerem a
          klientem: Testowano, czy format danych oraz zawartość są poprawnie przetwarzane
          na styku kodu Python'a oraz CUDA.
\end{itemize}

Wszystkie testy zostały pomyślnie zaliczone w obecnej wersji programu, co
potwierdza poprawność implementacji oraz zgodność wyników z teoretycznymi
oczekiwaniami.

\subsection{Wydajność}

W celu oceny wydajności implementacji program był wielokrotnie uruchamiany z
włączonym pełnym logowaniem każdego znalezionego punktu wyróżnionego. Wydajność
mierzono na podstawie przyrostu liczby znalezionych punktów w czasie, co pozwalało
na oszacowanie liczby iteracji dodawania punktów na sekundę.

Testy zostały przeprowadzone przy założeniu, że punkt wyróżniony spełnia warunek 20
najmłodszych bitów współrzędnej $x$ równych $0$ w reprezentacji bitowej.
Sumę znalezionych punktów wyróżnionych została obliczona w różnych odstępach czasu:
po 1 minucie oraz 5 minutach.

\begin{table}[h!]
    \centering
    \caption{Wyniki testów wydajności}
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Czas testu} & \textbf{Liczba znalezionych punktów} &
        \textbf{Średnia liczba iteracji/s}                                    \\ \hline
        1 minuta            & 5274                                 & 87,9 mln \\ \hline
        5 minut             & 26310                                & 87,7 mln \\ \hline
        % 10 minut            & <liczba punktów>                     & <wynik> \\ \hline
    \end{tabular}
    \label{tab:performance}
\end{table}

Na podstawie wyników testów oszacowano liczbę operacji dodawania punktów na
sekundę w algorytmie Rho Pollard'a. Prawdopodobieństwo znalezienia punktu wyróżnionego,
gdy 20 najmłodszych bitów współrzędnej $x$ wynosi $0$, można określić jako
$$
    P = 2^{-20}.
$$

Średnia liczba iteracji potrzebna do znalezienia punktu wyróżnionego wynosi
więc:
$$
    \text{Średnia liczba iteracji} = \frac{1}{P} = 2^{20}.
$$

Na podstawie wyników testów, można stwierdzić, że implementacja osiąga wydajność na
poziomie 87,7 milionów operacji dodawania punktów na sekundę.

\subsection{Rozwiązanie ECDLP dla krzywej ECCp79}

Najważniejszym wyznacznikiem osiągnięcia założonego celu tej pracy było
znalezienie poprawnego rozwiązania ECDLP dla krzywej z challenge'u Certicom ECCp79.
Po zweryfikowaniu poprawności implementacji na znacznie mniejszych rozmiarach
krzywych eliptycznych, przystąpiono do przeprowadzenia obliczeń dla docelowego
problemu. Proces ten wymagał wykonania dużej liczby iteracji algorytmu Rho Pollard'a,
a jego wyniki zostały szczegółowo udokumentowane w postaci zapisów logów.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{img/first_attempt.png}
    \caption{Wynik działania programu}
    \label{fig:first_attempt}
\end{figure}

Poniżej są zaprezentowane wyniki pięciu niezależnych prób obliczenia ECDLP dla
krzywej ECCp79, wskazujące liczbę znalezionych punktów wyróżnionych do momentu
znalezienia kolizji oraz czas trwania obliczeń.
\begin{table}[H]
    \centering
    \caption{Wyniki obliczeń ECDLP dla krzywej ECCp79}
    \label{tab:eccp79_results}
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Próba}   & \textbf{Liczba znalezionych punktów} &
        \textbf{Czas trwania obliczeń [s]}                                 \\ \hline
        1                & 1856364                              & 22195,42 \\ \hline
        2                & 791747                               & 9898,74  \\ \hline
        3                & 770077                               & 9329,74  \\ \hline
        4                & 1163047                              & 13681,16 \\ \hline
        5                & 1207014                              & 15001,94 \\ \hline
        \textbf{Średnia} & 1153649                              & 14021,00 \\ \hline
    \end{tabular}
\end{table}



\subsubsection{Weryfikacja wyników za pomocą SageMath.}
Aby upewnić się, że uzyskane rozwiązanie ECDLP jest poprawne, przeprowadzono
weryfikację przy użyciu oprogramowania SageMath. Weryfikacja polegała na
podstawieniu uzyskanego wyniku logarytmu dyskretnego do równania punktowego
na krzywej eliptycznej i sprawdzeniu, czy generuje on punkt
zgodny z założeniami wyzwania Certicom ECCp79.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{img/sage_check_full.png}
    \caption{Weryfikacja wyniku w SageMath}
    \label{fig:sage_verification}
\end{figure}

Weryfikacja potwierdziła poprawność uzyskanego wyniku, co dowodzi skuteczności
implementacji oraz poprawności algorytmu w zastosowaniu do krzywej ECCp79.

\subsection{Podsumowanie wyników.}
Na podstawie powyższych wyników można obliczyć średnią liczbę punktów wyróżnionych
znajdowanych przed wystąpieniem kolizji.
Porównanie wyniku z oczekiwanymi wartościami teoretycznymi, pozwoliło potwierdzić
osiągnięcie odpowiedniej losowości przy obliczaniu kolejnych kroków algorytmu.
Oczekiwaną liczbę punktów do znalezienia kolizji można oszacować na podstawie wzoru:
$$
    E = \frac{\sqrt{\pi \cdot n / 2}}{2^k}
$$
gdzie $n$ to liczność grupy punktów na krzywej eliptycznej, a $k$ to liczba bitów zerowych które decydują
czy dany punkt jest wyróżniony. W przypadku krzywej ECCp79,
dla $n \approx 2^{79}$, oraz punktów wyróżnionych których ostatnie 20 bitów to $0$, oczekiwana liczba
punktów potrzebna do znalezienia kolizji:
$$
    \frac{\sqrt{\pi \cdot 2^{79} / 2}}{2^{20}} = 929262.5811
$$
Uzyskany wynik na poziomie 1153649 jest bliski wartości oczekiwanej. Rozbieżność może wynikać z niewielkiej
liczby przeprowadzonych prób oraz ograniczonej liczby punktów wstępnie obliczonych.
Wydajność obliczeń jest zgodna z wynikami otrzymanymi podczas testów wydajności na ograniczonej liczbie iteracji algorytmu.
Najszybsze znalezienie logarytmu dyskretnego zajeło mniej niż 3 godziny, co jest bardzo zadowalającym wynikiem.

\subsection{Porównanie wyników}
Praca najbardziej zbliżona tematycznie do niniejszej, to \textit{Solving prime-field
    ECDLPs on GPUs with OpenCL} z 2015 roku, autorstwa Erika Boss'a \cite{Boss2015}.
Implementacja wykorzystana przez Boss'a opierała się na technologii
OpenCL i była zoptymalizowana pod kątem kart graficznych AMD, jednak również
dotyczyła problemu ECDLP dla krzywych modulo liczby pierwsze z Certicom Challenge.
Praca była zoptymalizowana pod konkretną kartę graficzną
oraz zastosowała technikę \textit{Negation Map} która pozwala przyśpieszyć czas obliczeń
o współczynnik $\sqrt{2}$ \cite{Negation}.
Osiągnęła ona wydajność 109 milionów iteracji dodawania punktów na sekundę dla karty AMD.
Wyniki uzyskane przez Bossa wskazują, że obliczenie
problemu logarytmu dyskretnego dla krzywej 112-bitowej zajęłoby odpowiednio 19,81
lat dla karty AMD HD7850 i 31,77 lat dla karty NVIDIA GTX 780.

Dla porównania, implementacja w niniejszej pracy przy użyciu karty NVIDIA GTX 2070
Super, uzyskała wydajność na poziomie 87,7 milionów iteracji na sekundę,
więc jest to wydajność zbliżoną rzędem wielkości do wyniku AMD z pracy Boss'a.
Ekstrapolując wydajność z działania na krzywej 79-bitowej,
rozwiązanie ECDLP dla krzywej 112-bitowej zajęłoby około 32 lat na karcie NVIDIA GTX 2070 Super:
$$
    \frac{\sqrt{\pi \cdot \frac{2^{112}}{2}}}{87.7 \cdot 10^{6} \cdot 3600 \cdot 24 \cdot 365} = 32.65
$$
W przypadku kart graficznych Nvidia, oba wyniki są prawie identyczne,
pomimo nowszej generacji karty graficznej użytej niniejszej pracy.

Wiele innych prac o podobnej tematyce również wykorzystuje GPU lub układy FPGA do
obliczania logarytmu dyskretnego. Jednak zazwyczaj dotyczą one krzywej
eliptycznej na ciele binarnym \cite{Wenger2014,FPGA2008,Majkowski2008}. W
takim przypadku porównanie traci na wartości, ponieważ na ciele binarnym
można zastosować więcej optymalizacji przy operacjach na krzywej \cite{Blake2005}.

W celach historycznych warto wspomnieć, że pierwsze złamanie krzywej ECCp79
udało się w 1997 roku \cite{certicom-cracked}. W tym celu wykorzystano kilka komputerów
współpracujących ze sobą, z czego pojedyncza stacja osiągała wydajność na
poziomie 25 bilionów operacji dodawania punktów na krzywej w ciągu dnia. Daje to około 289351,85 operacji na
sekundę, w porównaniu do 87,7 milionów operacji na sekundę w tej
implementacji.